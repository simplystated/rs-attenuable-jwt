//! This module provides a [verify] function for verifying attenuable JWTs created by calling [crate::sign::AttenuableJWT::seal].

use std::{
    borrow::Cow,
    collections::HashMap,
    time::{SystemTime, UNIX_EPOCH},
};

use base64::URL_SAFE_NO_PAD;
use serde::{de::DeserializeOwned, Deserialize, Serialize};

mod error;

pub use error::{Error, Result};

use crate::{
    protocol::{
        FullClaims, PublicKey, SealedClaims, SignedJWT, VerificationKeyManager,
        VerificationRequirements,
    },
    JWTHeader,
};

type GetKeyFn<'a> = Box<dyn FnOnce(Option<String>) -> Option<Box<dyn PublicKey + 'static>>>;

/// Verify the provided `jwt`, where `jwt` is expected to be in the format generated by [crate::sign::AttenuableJWT::seal]
///
/// ```
/// use attenuable_jwt::{SignedJWT, VerificationRequirements, VerificationKeyManager, SecondsSinceEpoch, Issuer, PublicKey, ed25519, verify::{verify, Result, Error}};
/// use std::collections::HashMap;
/// use serde::de::DeserializeOwned;
///
/// # fn generate_attenuated_jwt() -> std::result::Result<(ed25519::Ed25519PublicKey, SignedJWT), Box<dyn std::error::Error>> {
/// #   use std::{borrow::Cow, collections::HashMap, time::{SystemTime, UNIX_EPOCH}};
/// #   use attenuable_jwt::{AttenuationKeyGenerator, SigningKeyManager, sign::{Result, Error, AttenuableJWT}, ed25519};
/// #   
/// #   #[derive(Clone)]
/// #   struct KeyManager;
/// #
/// #   impl AttenuationKeyGenerator<ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey> for KeyManager {
/// #       fn generate_attenuation_key(
/// #           &self,
/// #       ) -> Result<(ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey)> {
/// #           ed25519::EddsaKeyGen.generate_attenuation_key()
/// #       }
/// #   }
/// #
/// #   impl SigningKeyManager for KeyManager {
/// #       type JWK = ed25519::JWK;
/// #
/// #       type PublicAttenuationKey = ed25519::Ed25519PublicKey;
/// #
/// #       type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;
/// #
/// #       type PrivateRootKey = ed25519::Ed25519PrivateKey;
/// #
/// #       type Claims = HashMap<String, String>;
/// #
/// #       fn jwk_for_public_attenuation_key(
/// #           public_attenuation_key: &Self::PublicAttenuationKey,
/// #       ) -> Self::JWK {
/// #           public_attenuation_key.into()
/// #       }
/// #   }
/// #
/// #   let claims = {
/// #       let mut claims = HashMap::new();
/// #       claims.insert("sub".to_owned(), "itsme".to_owned());
/// #       claims
/// #   };
/// #   let key_manager = KeyManager;
/// #   let (pub_key, priv_key) = key_manager.generate_attenuation_key()?;
/// #   let ajwt  = AttenuableJWT::new_with_key_manager(Cow::Borrowed(&key_manager), &priv_key, claims)?;
/// #   let attenuated_claims = {
/// #       let mut claims = HashMap::new();
/// #       claims.insert("aud".to_owned(), "restricted-audience".to_owned());
/// #       claims
/// #   };
/// #   let attenuated = ajwt.attenuate(attenuated_claims)?;
/// #   let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
/// #   let jwt = attenuated.seal(SecondsSinceEpoch(current_time + 60), SecondsSinceEpoch(current_time), Some(Issuer("my-issuer".to_owned())), None)?;
/// #   Ok((pub_key, jwt))
/// # }
///
/// #[derive(Clone)]
/// struct KeyManager {
///     pub_root_key: ed25519::Ed25519PublicKey,
/// }
///
/// impl VerificationKeyManager for KeyManager {
///     type PublicRootKey = ed25519::Ed25519PublicKey;
///
///     type PublicAttenuationKey = ed25519::Ed25519PublicKey;
///
///     type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;
///
///     type Claims = std::collections::HashMap<String, String>;
///
///     type JWK = ed25519::JWK;
///
///     fn get_root_key(&self, key_id: &Option<String>) -> Option<Self::PublicRootKey> {
///         if key_id.as_ref().map(|kid| kid == self.pub_root_key.key_id()).unwrap_or(true) {
///             Some(self.pub_root_key.clone())
///         } else {
///             None
///         }
///     }
///
///     fn get_envelope_verification_requirements(&self) -> VerificationRequirements {
///         VerificationRequirements::VerifyClaims {
///             acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
///             acceptable_issuers: Some(vec![Issuer("my-issuer".to_owned())]),
///             acceptable_audiences: None,
///             acceptable_subject: None,
///         }
///     }
///
///     fn default_claims(&self) -> Self::Claims {
///         HashMap::new()
///     }
///
///     fn jwk_to_public_attenuation_key(&self, jwk: &Self::JWK) -> Option<Self::PublicAttenuationKey> {
///         jwk.try_into().ok()
///     }
/// }
///
/// # fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
/// let (pub_root_key, attenuated_jwt) = generate_attenuated_jwt()?;
/// let key_manager = KeyManager {
///     pub_root_key,
/// };
/// let claims = verify(
///     key_manager,
///     attenuated_jwt,
///     |c1, c2| {
///         c2
///             .into_iter()
///             .map(|(k, v)| (k.clone(), v.clone()))
///             .chain(c1.into_iter())
///             .collect()
///     }
/// )?;
/// let sub = claims.get("sub").unwrap();
/// assert_eq!(sub, "itsme");
/// let aud = claims.get("aud").unwrap();
/// assert_eq!(aud, "restricted-audience");
/// # Ok(())
/// # }
///
/// ```
pub fn verify<VKM: VerificationKeyManager + 'static, ClaimResolver>(
    verification_key_manager: VKM,
    jwt: SignedJWT,
    resolve_claims: ClaimResolver,
) -> Result<VKM::Claims>
where
    ClaimResolver: Fn(VKM::Claims, VKM::Claims) -> VKM::Claims,
{
    let envelope_key: VKM::PublicAttenuationKey =
        final_attenuation_key(&verification_key_manager, &jwt)?;
    let header = jwt.decode_jwt_header()?;
    let kid_matches = header
        .key_id
        .as_ref()
        .map(|kid| kid == envelope_key.key_id())
        .unwrap_or(false);
    if !kid_matches {
        return Err(Error::InvalidEnvelopeKey);
    }
    if header.algorithm != envelope_key.algorithm() {
        return Err(Error::InvalidEnvelopeKey);
    }
    let verification_reqs = verification_key_manager.get_envelope_verification_requirements();
    let claims: SealedClaims = jwt.decode_jwt(&envelope_key, &verification_reqs)?;
    let jwts = claims.jwts;

    let default_claims = verification_key_manager.default_claims();
    let vkm = verification_key_manager.clone(); // TODO: this is silly
    let get_root_key = Box::new(move |kid| {
        vkm.get_root_key(&kid)
            .map(|rk| Box::new(rk) as Box<dyn PublicKey>)
    }) as GetKeyFn;
    let (_, claims) = jwts.into_iter().fold(
        Ok((get_root_key, default_claims)),
        |accumulated, jwt| -> Result<(_, VKM::Claims)> {
            let (get_key, acc) = accumulated?;
            let full_claims: FullClaims<VKM::JWK, VKM::Claims> = decode_inner_jwt(&jwt, get_key)?;
            let next_pub_key =
                verification_key_manager.jwk_to_public_attenuation_key(&full_claims.aky);
            let get_key = Box::new(move |kid: Option<String>| {
                next_pub_key.and_then(|p| {
                    let kids_match = kid.as_ref().map(|kid| kid == p.key_id()).unwrap_or(true);
                    if kids_match {
                        Some(Box::new(p) as Box<dyn PublicKey>)
                    } else {
                        None
                    }
                })
            }) as GetKeyFn;
            let accumulated = resolve_claims(acc, full_claims.user_provided_claims);
            Ok((get_key, accumulated))
        },
    )?;
    Ok(claims)
}

fn final_attenuation_key<VKM: VerificationKeyManager>(
    verification_key_manager: &VKM,
    jwt: &SignedJWT,
) -> Result<VKM::PublicAttenuationKey> {
    let claims: SealedClaims = jwt.insecurely_decode_jwt()?;

    claims
        .jwts
        .last()
        .ok_or(Error::MissingFinalAttenuationKey)
        .and_then(|jwt| extract_aky(verification_key_manager, jwt))
}

fn extract_aky<VKM: VerificationKeyManager>(
    verification_key_manager: &VKM,
    jwt: &SignedJWT,
) -> Result<VKM::PublicAttenuationKey> {
    let claims: FullClaims<VKM::JWK, HashMap<String, String>> = jwt.insecurely_decode_jwt()?;
    verification_key_manager
        .jwk_to_public_attenuation_key(&claims.aky)
        .ok_or(Error::MalformedAttenuationKeyJWK)
}

fn decode_inner_jwt<Claims: DeserializeOwned>(
    jwt: &SignedJWT,
    get_key: GetKeyFn,
) -> Result<Claims> {
    let header = jwt.decode_jwt_header()?;
    let kid = header.key_id.clone();
    let public_key = get_key(kid).ok_or_else(|| Error::MissingKey(header.key_id.clone()))?;
    jwt.decode_jwt(
        public_key.as_ref(),
        &VerificationRequirements::VerifySignatureOnly {
            acceptable_algorithms: vec![public_key.algorithm().to_owned()],
        },
    )
}

/// Trait for decoding JWTs.
trait JWTDecoder {
    /// Decode the provided JWT given the `verification_key` and the `verification_reqs`.
    /// If the `verification_reqs` are not met, return an `Err` of [crate::verify::Error].
    /// If the `verification_reqs` are met, return `Ok(Claims)`.
    fn decode_jwt<Claims: DeserializeOwned, PubKey: PublicKey + ?Sized>(
        &self,
        verification_key: &PubKey,
        verification_reqs: &VerificationRequirements,
    ) -> crate::verify::Result<Claims>;
    /// INSECURELY decode the JWT, returning its contained `Claims` without verifying the signature or claims.
    fn insecurely_decode_jwt<Claims: DeserializeOwned>(&self) -> crate::verify::Result<Claims>;
    /// Decode the JWT's header only.
    fn decode_jwt_header(&self) -> crate::verify::Result<JWTHeader>;
}

#[derive(Serialize, Deserialize)]
struct VerificationClaims<'a> {
    exp: Option<u64>,
    nbf: Option<u64>,
    iss: Option<Cow<'a, str>>,
    aud: Option<Cow<'a, str>>,
    sub: Option<Cow<'a, str>>,
}

fn verify_claims(claims: &VerificationClaims, reqs: &VerificationRequirements) -> bool {
    match reqs {
        VerificationRequirements::VerifyClaims {
            acceptable_algorithms: _,
            acceptable_issuers,
            acceptable_audiences,
            acceptable_subject,
        } => {
            let current_time = match SystemTime::now().duration_since(UNIX_EPOCH) {
                Ok(t) => t,
                Err(_) => {
                    return false;
                }
            }
            .as_secs();

            if claims.exp.map(|exp| exp < current_time).unwrap_or(false) {
                return false;
            }

            if claims.nbf.map(|nbf| nbf > current_time).unwrap_or(false) {
                return false;
            }

            if let Some(issuers) = acceptable_issuers {
                if !issuers.iter().any(|iss| {
                    claims
                        .iss
                        .as_ref()
                        .map(|c| c.as_ref() == iss.as_ref())
                        .unwrap_or(false)
                }) {
                    return false;
                }
            }

            if let Some(audiences) = acceptable_audiences {
                if !audiences.iter().any(|aud| {
                    claims
                        .aud
                        .as_ref()
                        .map(|c| c.as_ref() == aud.as_ref())
                        .unwrap_or(false)
                }) {
                    return false;
                }
            }

            if let Some(sub) = acceptable_subject {
                if !claims
                    .sub
                    .as_ref()
                    .map(|c| c.as_ref() == sub)
                    .unwrap_or(false)
                {
                    return false;
                }
            }

            true
        }
        VerificationRequirements::VerifySignatureOnly {
            acceptable_algorithms: _,
        } => true,
    }
}

impl<T: JWTParts> JWTDecoder for T {
    fn decode_jwt<Claims: DeserializeOwned, PubKey: PublicKey + ?Sized>(
        &self,
        verification_key: &PubKey,
        verification_reqs: &VerificationRequirements,
    ) -> crate::verify::Result<Claims> {
        let (msg, header, body, sig) = self.jwt_parts()?;
        let header: JWTHeader = header.as_ref().deserialize()?;
        if header.algorithm != verification_key.algorithm() {
            return Err(Error::InvalidAlgorithm);
        }
        if !verification_reqs
            .acceptable_algorithms()
            .contains(&header.algorithm)
        {
            return Err(Error::InvalidAlgorithm);
        }
        let verified =
            verification_key.verify(msg.as_ref().as_bytes(), sig.as_ref().to_bytes()?.as_slice());
        return if !verified {
            Err(Error::InvalidSignature)
        } else {
            let body_bytes = body.as_ref().to_bytes()?;
            let verification_claims = serde_json::from_slice(&body_bytes)
                .map_err(|err| Error::InvalidClaimFormat(Box::new(err)))?;
            return if verify_claims(&verification_claims, verification_reqs) {
                body.as_ref().deserialize()
            } else {
                Err(Error::InvalidClaims)
            };
        };
    }

    fn insecurely_decode_jwt<Claims: DeserializeOwned>(&self) -> crate::verify::Result<Claims> {
        let (_, _, body, _) = self.jwt_parts()?;
        body.as_ref().deserialize()
    }

    fn decode_jwt_header(&self) -> crate::verify::Result<JWTHeader> {
        let (_, raw_header, _, _) = self.jwt_parts()?;
        raw_header.as_ref().deserialize()
    }
}

trait JWTParts {
    fn jwt_parts(&self) -> Result<(RawJWTMessage, RawJWTHeader, RawJWTBody, RawJWTSignature)>;
}

impl JWTParts for SignedJWT {
    fn jwt_parts(&self) -> Result<(RawJWTMessage, RawJWTHeader, RawJWTBody, RawJWTSignature)> {
        let mut sig_split = self.as_ref().rsplitn(2, '.');
        if let Some(sig) = sig_split.next() {
            if let Some(message) = sig_split.next() {
                let mut msg_split = message.split('.');
                if let Some(header) = msg_split.next() {
                    if let Some(body) = msg_split.next() {
                        return if msg_split.next().is_some() {
                            Err(Error::InvalidJWTFormat)
                        } else {
                            Ok((
                                RawJWTMessage(message),
                                RawJWTHeader(Base64Content(header)),
                                RawJWTBody(Base64Content(body)),
                                RawJWTSignature(Base64Content(sig)),
                            ))
                        };
                    }
                }
            }
        }

        Err(Error::InvalidJWTFormat)
    }
}

struct RawJWTMessage<'a>(&'a str);

impl<'a> AsRef<str> for RawJWTMessage<'a> {
    fn as_ref(&self) -> &'a str {
        self.0
    }
}

struct RawJWTSignature<'a>(Base64Content<'a>);

impl<'a> AsRef<Base64Content<'a>> for RawJWTSignature<'a> {
    fn as_ref(&self) -> &Base64Content<'a> {
        &self.0
    }
}

struct RawJWTBody<'a>(Base64Content<'a>);

impl<'a> AsRef<Base64Content<'a>> for RawJWTBody<'a> {
    fn as_ref(&self) -> &Base64Content<'a> {
        &self.0
    }
}

struct RawJWTHeader<'a>(Base64Content<'a>);

impl<'a> AsRef<Base64Content<'a>> for RawJWTHeader<'a> {
    fn as_ref(&self) -> &Base64Content<'a> {
        &self.0
    }
}

struct Base64Content<'a>(&'a str);

impl<'a> Base64Content<'a> {
    fn to_bytes(&self) -> Result<Vec<u8>> {
        base64::decode_config(&self.0, URL_SAFE_NO_PAD)
            .map_err(|err| Error::InvalidBase64Encoding(Box::new(err)))
    }

    fn deserialize<T: DeserializeOwned>(&self) -> Result<T> {
        let bytes = self.to_bytes()?;
        serde_json::from_slice(&bytes).map_err(|err| Error::InvalidClaimFormat(Box::new(err)))
    }
}

#[cfg(test)]
mod test {
    use crate::{
        ed25519,
        sign::{AttenuableJWT, Error as SignError},
        verify::Error,
        AttenuationKeyGenerator, FullClaims, Issuer, PrivateKey, SealedClaims, SecondsSinceEpoch,
        SignedJWT, SigningKeyManager, VerificationKeyManager, VerificationRequirements,
    };
    use jsonwebtoken::EncodingKey;
    use mockall::mock;
    use serde::Serialize;
    use std::{
        borrow::Cow,
        collections::HashMap,
        str::FromStr,
        time::{SystemTime, UNIX_EPOCH},
    };

    use super::verify;

    const EXPECTED_ISSUER: &str = "my-issuer";

    mock! {
        KeyManager {}

        impl VerificationKeyManager for KeyManager {
            type PublicRootKey = ed25519::Ed25519PublicKey;

            type PublicAttenuationKey = ed25519::Ed25519PublicKey;

            type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;

            type Claims = std::collections::HashMap<String, String>;

            type JWK = ed25519::JWK;

            fn get_root_key(&self, key_id: &Option<String>) -> Option<<MockKeyManager as VerificationKeyManager>::PublicRootKey>;
            fn get_envelope_verification_requirements(&self) -> VerificationRequirements;
            fn default_claims(&self) -> <MockKeyManager as VerificationKeyManager>::Claims;
            fn jwk_to_public_attenuation_key(&self, jwk: &<MockKeyManager as VerificationKeyManager>::JWK) -> Option<<MockKeyManager as VerificationKeyManager>::PublicAttenuationKey>;
        }

        impl Clone for KeyManager {
            fn clone(&self) -> Self;
        }
    }

    fn to_encoding_key<PrivKey: PrivateKey>(k: &PrivKey) -> Result<EncodingKey> {
        let mut json: Vec<u8> = Default::default();
        erased_serde::serialize(k, &mut serde_json::Serializer::new(&mut json))
            .map_err(|_| crate::verify::Error::InvalidKey)?;
        let jwk: ed25519::JWK =
            serde_json::from_slice(&json).map_err(|_| crate::verify::Error::InvalidKey)?;
        if let Some(d) = &jwk.d {
            let x = base64::decode_config(&jwk.x, base64::URL_SAFE_NO_PAD)?;
            let d = base64::decode_config(&d, base64::URL_SAFE_NO_PAD)?;
            let der: Vec<_> = x.into_iter().chain(d.into_iter()).collect();
            let encoding_key = EncodingKey::from_ed_der(&der);
            Ok(encoding_key)
        } else {
            Err(Error::InvalidKey)?
        }
    }

    type Result<R> = std::result::Result<R, Box<dyn std::error::Error>>;

    fn make_inner_jwt<SignWith: PrivateKey, NextKeyJWK: Serialize>(
        sign_with: SignWith,
        next_key_jwk: NextKeyJWK,
    ) -> Result<SignedJWT> {
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &sign_with.algorithm(),
            )?);
            header.kid = Some(sign_with.key_id().to_owned());
            header
        };
        let claims: FullClaims<NextKeyJWK, HashMap<String, String>> =
            FullClaims::new(Default::default(), next_key_jwk);
        let inner_jwt = jsonwebtoken::encode(&header, &claims, &to_encoding_key(&sign_with)?)?;
        Ok(SignedJWT(inner_jwt))
    }

    fn make_envelope_jwt<SignWith: PrivateKey>(
        sign_with: SignWith,
        inner_jwts: Vec<SignedJWT>,
    ) -> Result<SignedJWT> {
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &sign_with.algorithm(),
            )?);
            header.kid = Some(sign_with.key_id().to_owned());
            header
        };
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let full_claims = SealedClaims {
            exp: Some(SecondsSinceEpoch(current_time + 60)),
            nbf: Some(SecondsSinceEpoch(current_time)),
            iss: Some(Issuer(EXPECTED_ISSUER.to_owned())),
            aud: None,
            jwts: inner_jwts,
        };
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&sign_with)?)?;
        Ok(SignedJWT(token))
    }

    #[test]
    fn test_wrong_aky_chain() -> Result<()> {
        let (root_pub_key, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let ajwk = AttenuableJWT::new_with_key_manager(
            Cow::Borrowed(&SignKeyManager),
            &root_priv_key,
            HashMap::new(),
        )
        .map_err(|err| Error::InvalidAttenuationKey(Box::new(err)))?;
        let (_, wrong_aky) = SignKeyManager.generate_attenuation_key()?;
        let ajwk = AttenuableJWT::with_key_manager(
            Cow::Borrowed(&SignKeyManager),
            ajwk.jwts().to_vec(),
            wrong_aky,
        );
        let ajwk = ajwk
            .attenuate({
                let mut h = HashMap::new();
                h.insert("a".to_owned(), "b".to_owned());
                h
            })
            .map_err(|err| Error::InvalidAttenuationKey(Box::new(err)))?;

        let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let token = ajwk
            .seal(
                SecondsSinceEpoch(current_time + 60),
                SecondsSinceEpoch(current_time),
                Some(Issuer(EXPECTED_ISSUER.to_owned())),
                None,
            )
            .map_err(|err| Error::InvalidAttenuationKey(Box::new(err)))?;

        fn make_key_manager(root_key: ed25519::Ed25519PublicKey) -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
                .expect_default_claims()
                .returning(|| Default::default());
            let cloned_root_key = root_key.clone();
            key_manager
                .expect_clone()
                .returning(move || make_key_manager(cloned_root_key.clone()));
            key_manager
                .expect_get_root_key()
                .returning(move |_| Some(root_key.clone()));
            key_manager
        }

        let key_manager = make_key_manager(root_pub_key);
        let err = verify(key_manager, token, |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::InvalidSignature
        ));

        Ok(())
    }

    #[test]
    fn test_wrong_envelope_key() -> Result<()> {
        let (_, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let ajwk = AttenuableJWT::new_with_key_manager(
            Cow::Borrowed(&SignKeyManager),
            &root_priv_key,
            HashMap::new(),
        )
        .map_err(|err| Error::InvalidAttenuationKey(Box::new(err)))?;
        let (_, wrong_aky) = SignKeyManager.generate_attenuation_key()?;
        let ajwk = AttenuableJWT::with_key_manager(
            Cow::Borrowed(&SignKeyManager),
            ajwk.jwts().to_vec(),
            wrong_aky,
        );
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let token = ajwk
            .seal(
                SecondsSinceEpoch(current_time + 60),
                SecondsSinceEpoch(current_time),
                Some(Issuer(EXPECTED_ISSUER.to_owned())),
                None,
            )
            .map_err(|err| Error::InvalidAttenuationKey(Box::new(err)))?;

        fn make_key_manager() -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
        }

        let key_manager = make_key_manager();
        let err = verify(key_manager, token.clone(), |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::InvalidSignature
        ));

        Ok(())
    }

    #[test]
    fn test_bad_envelope_kid() -> Result<()> {
        let (_, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &root_priv_key.algorithm(),
            )?);
            header.kid = Some("wrong".to_owned());
            header
        };
        let full_claims = SealedClaims {
            exp: None,
            nbf: None,
            iss: None,
            aud: None,
            jwts: Default::default(),
        };
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&root_priv_key)?)?;

        let key_manager = MockKeyManager::new();
        let err = verify(key_manager, SignedJWT(token), |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::MissingFinalAttenuationKey
        ));

        Ok(())
    }

    #[test]
    fn test_missing_jwts_claim() -> Result<()> {
        let (_, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &root_priv_key.algorithm(),
            )?);
            header.kid = Some(root_priv_key.key_id().to_owned());
            header
        };
        // no jwts claim
        let full_claims: HashMap<String, String> = Default::default();
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&root_priv_key)?)?;

        let key_manager = MockKeyManager::new();
        let err = verify(key_manager, SignedJWT(token), |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::InvalidClaimFormat(_)
        ));

        Ok(())
    }

    #[test]
    fn test_bad_encoding() {
        let key_manager = MockKeyManager::new();
        let err = verify(
            key_manager,
            SignedJWT("*&.*&.*&".to_owned()),
            |mut c1, c2| {
                c1.extend(c2);
                c1
            },
        );

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::InvalidBase64Encoding(_)
        ));
    }

    #[test]
    fn test_bad_jwt_format() {
        let key_manager = MockKeyManager::new();
        let err = verify(key_manager, SignedJWT("a".to_owned()), |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::InvalidJWTFormat
        ));
    }

    #[test]
    fn test_missing_root_key() -> Result<()> {
        fn make_key_manager() -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
                .expect_default_claims()
                .returning(|| Default::default());
            key_manager.expect_clone().returning(|| make_key_manager());
            key_manager.expect_get_root_key().returning(|_| None);
            key_manager
        }

        let (envelope_pub_key, envelope_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let (_, inner_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let inner = make_inner_jwt(inner_priv_key, ed25519::JWK::from(&envelope_pub_key))?;
        let jwt = make_envelope_jwt(envelope_priv_key, vec![inner])?;

        let key_manager = make_key_manager();
        let err = verify(key_manager, jwt, |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        if let Error::MissingKey(Some(kid)) = err.expect_err("should have failed") {
            assert_eq!(kid, "aky");
        } else {
            assert!(false, "expected a MissingKey error");
        }

        Ok(())
    }

    #[derive(Clone)]
    struct SignKeyManager;

    impl AttenuationKeyGenerator<ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey>
        for SignKeyManager
    {
        fn generate_attenuation_key(
            &self,
        ) -> std::result::Result<(ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey), SignError>
        {
            ed25519::EddsaKeyGen.generate_attenuation_key()
        }
    }

    impl SigningKeyManager for SignKeyManager {
        type JWK = ed25519::JWK;

        type PublicAttenuationKey = ed25519::Ed25519PublicKey;

        type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;

        type PrivateRootKey = ed25519::Ed25519PrivateKey;

        type Claims = HashMap<String, String>;

        fn jwk_for_public_attenuation_key(
            public_attenuation_key: &Self::PublicAttenuationKey,
        ) -> Self::JWK {
            public_attenuation_key.into()
        }
    }
}
