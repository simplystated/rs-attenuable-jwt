//! This module provides a [verify] function for verifying attenuable JWTs created by calling [crate::sign::AttenuableJWT::seal].

use std::collections::HashMap;

use serde::de::DeserializeOwned;

mod error;

pub use error::{Error, Result};

use crate::protocol::{
    FullClaims, JWTDecoder, PublicKey, SealedClaims, SignedJWT, VerificationKeyManager,
    VerificationRequirements,
};

type GetKeyFn<'a> = Box<dyn FnOnce(Option<String>) -> Option<Box<dyn PublicKey + 'static>>>;

/// Verify the provided `jwt`, where `jwt` is expected to be in the format generated by [crate::sign::AttenuableJWT::seal]
///
/// ```
/// use attenuable_jwt::{protocol::{SignedJWT, PublicKey, VerificationRequirements, VerificationKeyManager, SecondsSinceEpoch, Issuer, JWTHeader, JWTDecoder}, ed25519, verify::{verify, Result, Error}};
/// use std::collections::HashMap;
/// use jsonwebtoken::{decode, decode_header, DecodingKey, Validation, Algorithm};
/// use serde::de::DeserializeOwned;
///
/// # fn generate_attenuated_jwt() -> std::result::Result<(ed25519::Ed25519PublicKey, SignedJWT), Box<dyn std::error::Error>> {
/// #   use std::{borrow::Cow, collections::HashMap, time::{SystemTime, UNIX_EPOCH}, str::FromStr};
/// #   use attenuable_jwt::{protocol::{AttenuationKeyGenerator, SigningKeyManager, JWTHeader, PrivateKey, JWTEncoder}, sign::{Result, Error, AttenuableJWT}, ed25519};
/// #   use jsonwebtoken::{encode, EncodingKey};
/// #   
/// #   #[derive(Clone)]
/// #   struct JsonwebtokenEncoder;
/// #   
/// #   impl JWTEncoder for JsonwebtokenEncoder {
/// #       fn encode_jwt<Claims: serde::Serialize, PrivKey: PrivateKey + ?Sized>(
/// #           &self,
/// #           header: &JWTHeader,
/// #           claims: &Claims,
/// #           signing_key: &PrivKey,
/// #       ) -> Result<SignedJWT> {
/// #               let mut json: Vec<u8> = Default::default();
/// #               erased_serde::serialize(
/// #                   signing_key,
/// #                   &mut serde_json::Serializer::new(&mut json),
/// #               )
/// #               .map_err(|err| Error::KeyError(Some(Box::new(err))))?;
/// #               let jwk: ed25519::JWK =
/// #                   serde_json::from_slice(&json).map_err(|err| Error::KeyError(Some(Box::new(err))))?;
/// #               if let Some(d) = &jwk.d {
/// #                   let x = base64::decode_config(&jwk.x, base64::URL_SAFE_NO_PAD).map_err(|err| Error::KeyError(Some(Box::new(err))))?;
/// #                   let d = base64::decode_config(d, base64::URL_SAFE_NO_PAD).map_err(|err| Error::KeyError(Some(Box::new(err))))?;
/// #                   let der: Vec<_> = x.into_iter().chain(d.into_iter()).collect();
/// #                   let encoding_key = EncodingKey::from_ed_der(&der);
/// #                   let header = {
/// #                       let mut h = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
/// #                           &header.algorithm,
/// #                       ).map_err(|err| Error::KeyError(Some(Box::new(err))))?);
/// #                       h.kid = header.key_id.clone();
/// #                       h
/// #                   };
/// #                   let token = encode(
/// #                       &header,
/// #                       claims,
/// #                       &encoding_key,
/// #                   ).map_err(|err| Error::CryptoError(Some(Box::new(err))))?;
/// #                   Ok(SignedJWT(token))
/// #               } else {
/// #                   Err(Error::KeyError(None))
/// #               }
/// #       }
/// #   }
/// #
/// #   #[derive(Clone)]
/// #   struct KeyManager;
/// #
/// #   impl AttenuationKeyGenerator<ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey> for KeyManager {
/// #       fn generate_attenuation_key(
/// #           &self,
/// #       ) -> Result<(ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey)> {
/// #           ed25519::EddsaKeyGen.generate_attenuation_key()
/// #       }
/// #   }
/// #
/// #   impl SigningKeyManager for KeyManager {
/// #       type JWK = ed25519::JWK;
/// #
/// #       type PublicAttenuationKey = ed25519::Ed25519PublicKey;
/// #
/// #       type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;
/// #
/// #       type PrivateRootKey = ed25519::Ed25519PrivateKey;
/// #
/// #       type Claims = HashMap<String, String>;
/// #
/// #       fn jwk_for_public_attenuation_key(
/// #           public_attenuation_key: &Self::PublicAttenuationKey,
/// #       ) -> Self::JWK {
/// #           public_attenuation_key.into()
/// #       }
/// #   }
/// #
/// #   let claims = {
/// #       let mut claims = HashMap::new();
/// #       claims.insert("sub".to_owned(), "itsme".to_owned());
/// #       claims
/// #   };
/// #   let key_manager = KeyManager;
/// #   let (pub_key, priv_key) = key_manager.generate_attenuation_key()?;
/// #   let ajwt  = AttenuableJWT::new_with_key_manager(Cow::Borrowed(&key_manager), Cow::Borrowed(&JsonwebtokenEncoder), &priv_key, claims)?;
/// #   let attenuated_claims = {
/// #       let mut claims = HashMap::new();
/// #       claims.insert("aud".to_owned(), "restricted-audience".to_owned());
/// #       claims
/// #   };
/// #   let attenuated = ajwt.attenuate(attenuated_claims)?;
/// #   let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
/// #   let jwt = attenuated.seal(SecondsSinceEpoch(current_time + 60), SecondsSinceEpoch(current_time), Some(Issuer("my-issuer".to_owned())), None)?;
/// #   Ok((pub_key, jwt))
/// # }
///
/// #[derive(Clone)]
/// struct KeyManager {
///     pub_root_key: ed25519::Ed25519PublicKey,
/// }
///
/// impl VerificationKeyManager for KeyManager {
///     type PublicRootKey = ed25519::Ed25519PublicKey;
///
///     type PublicAttenuationKey = ed25519::Ed25519PublicKey;
///
///     type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;
///
///     type Claims = std::collections::HashMap<String, String>;
///
///     type JWK = ed25519::JWK;
///
///     fn get_root_key(&self, key_id: &Option<String>) -> Option<Self::PublicRootKey> {
///         if key_id.as_ref().map(|kid| kid == self.pub_root_key.key_id()).unwrap_or(true) {
///             Some(self.pub_root_key.clone())
///         } else {
///             None
///         }
///     }
///
///     fn get_envelope_verification_requirements(&self) -> VerificationRequirements {
///         VerificationRequirements::VerifyClaims {
///             acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
///             acceptable_issuers: Some(vec![Issuer("my-issuer".to_owned())]),
///             acceptable_audiences: None,
///             acceptable_subject: None,
///         }
///     }
///
///     fn default_claims(&self) -> Self::Claims {
///         HashMap::new()
///     }
///
///     fn jwk_to_public_attenuation_key(&self, jwk: &Self::JWK) -> Option<Self::PublicAttenuationKey> {
///         jwk.try_into().ok()
///     }
/// }
///
/// struct VerifyJWTDecoder;
///
/// impl JWTDecoder for VerifyJWTDecoder {
///     fn decode_jwt<Claims: DeserializeOwned, PubKey: PublicKey + ?Sized>(
///         &self,
///         jwt: &SignedJWT,
///         verification_key: &PubKey,
///         verification_reqs: &VerificationRequirements,
///     ) -> Result<Claims> {
///         let mut json: Vec<u8> = Default::default();
///         erased_serde::serialize(
///             verification_key,
///             &mut serde_json::Serializer::new(&mut json),
///         )
///         .map_err(|_| Error::InvalidKey)?;
///         let jwk: ed25519::JWK =
///             serde_json::from_slice(&json).map_err(|_| Error::InvalidKey)?;
///         let x = base64::decode_config(&jwk.x, base64::URL_SAFE_NO_PAD).map_err(|_| Error::InvalidKey)?;
///         let decoding_key = DecodingKey::from_ed_der(&x);
///         Ok(decode(
///             jwt.as_ref(),
///             &decoding_key,
///             &validation_config(verification_reqs)?,
///         ).map_err(|err| Error::JWTError(Some(Box::new(err))))?
///         .claims)
///     }
///      fn insecurely_decode_jwt<Claims: DeserializeOwned>(
///         &self,
///         jwt: &SignedJWT,
///     ) -> Result<Claims> {
///         let no_validation = {
///             let mut v = Validation::default();
///             v.required_spec_claims.clear();
///             v.insecure_disable_signature_validation();
///             v
///         };
///         Ok(decode(
///             jwt.as_ref(),
///             &DecodingKey::from_secret("fake".as_ref()),
///             &no_validation,
///         ).map_err(|err| Error::JWTError(Some(Box::new(err))))?
///         .claims)
///     }
///      fn decode_jwt_header(&self, jwt: &SignedJWT) -> Result<JWTHeader> {
///         let header = decode_header(jwt.as_ref()).map_err(|err| Error::JWTError(Some(Box::new(err))))?;
///         Ok(JWTHeader {
///             key_id: header.kid,
///             algorithm: format!("{:?}", header.alg),
///         })
///     }
/// }
///
/// # fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
/// let (pub_root_key, attenuated_jwt) = generate_attenuated_jwt()?;
/// let key_manager = KeyManager {
///     pub_root_key,
/// };
/// let jwt_decoder = VerifyJWTDecoder;
/// let claims = verify(
///     key_manager,
///     &jwt_decoder,
///     attenuated_jwt,
///     |c1, c2| {
///         c2
///             .into_iter()
///             .map(|(k, v)| (k.clone(), v.clone()))
///             .chain(c1.into_iter())
///             .collect()
///     }
/// )?;
/// let sub = claims.get("sub").unwrap();
/// assert_eq!(sub, "itsme");
/// let aud = claims.get("aud").unwrap();
/// assert_eq!(aud, "restricted-audience");
/// # Ok(())
/// # }
///
/// fn validation_config(reqs: &VerificationRequirements) -> Result<Validation> {
///     match reqs {
///         VerificationRequirements::VerifyClaims {
///             acceptable_algorithms,
///             acceptable_audiences,
///             acceptable_issuers,
///             acceptable_subject,
///         } => {
///             let required_spec_claims = {
///                 let mut required_spec_claims = vec!["exp".to_owned()];
///                  if acceptable_audiences.is_some() {
///                     required_spec_claims.push("aud".to_owned());
///                 }
///                  if acceptable_issuers.is_some() {
///                     required_spec_claims.push("iss".to_owned());
///                 }
///                  if acceptable_subject.is_some() {
///                     required_spec_claims.push("sub".to_owned());
///                 }
///                  required_spec_claims
///             };
///              let mut v = Validation::default();
///             v.set_required_spec_claims(required_spec_claims.as_slice());
///             v.validate_nbf = true;
///             if let Some(issuers) = acceptable_issuers.as_ref() {
///                 v.set_issuer(
///                     issuers
///                         .iter()
///                         .map(|i| i.as_ref())
///                         .collect::<Vec<_>>()
///                         .as_slice(),
///                 )
///             }
///             if let Some(audiences) = acceptable_audiences.as_ref() {
///                 v.set_audience(
///                     audiences
///                         .iter()
///                         .map(|a| a.as_ref())
///                         .collect::<Vec<_>>()
///                         .as_slice(),
///                 )
///             }
///             v.sub = acceptable_subject.clone();
///             v.algorithms = acceptable_algorithms
///                 .iter()
///                 .map(|alg| alg.to_string().parse())
///                 .collect::<std::result::Result<_, _>>()
///                 .map_err(|err| Error::JWTError(Some(Box::new(err))))?;
///              Ok(v)
///         }
///         VerificationRequirements::VerifySignatureOnly {
///             acceptable_algorithms,
///         } => {
///             let mut v = Validation::default();
///             v.set_required_spec_claims(&[] as &[&str]);
///             v.algorithms = acceptable_algorithms
///                 .iter()
///                 .map(|alg| alg.parse())
///                 .collect::<std::result::Result<Vec<Algorithm>, jsonwebtoken::errors::Error>>(
///             ).map_err(|err| Error::JWTError(Some(Box::new(err))))?;
///             Ok(v)
///         }
///     }
/// }
///
/// ```
pub fn verify<VKM: VerificationKeyManager + 'static, JWTD: JWTDecoder, ClaimResolver>(
    verification_key_manager: VKM,
    jwt_decoder: &JWTD,
    jwt: SignedJWT,
    resolve_claims: ClaimResolver,
) -> Result<VKM::Claims>
where
    ClaimResolver: Fn(VKM::Claims, VKM::Claims) -> VKM::Claims,
{
    let envelope_key: VKM::PublicAttenuationKey =
        final_attenuation_key(&verification_key_manager, jwt_decoder, &jwt)?;
    let header = jwt_decoder.decode_jwt_header(&jwt)?;
    let kid_matches = header
        .key_id
        .as_ref()
        .map(|kid| kid == envelope_key.key_id())
        .unwrap_or(false);
    if !kid_matches {
        return Err(Error::InvalidEnvelopeKey);
    }
    if header.algorithm != envelope_key.algorithm() {
        return Err(Error::InvalidEnvelopeKey);
    }
    let verification_reqs = verification_key_manager.get_envelope_verification_requirements();
    let claims: SealedClaims = jwt_decoder.decode_jwt(&jwt, &envelope_key, &verification_reqs)?;
    let jwts = claims.jwts;

    let default_claims = verification_key_manager.default_claims();
    let vkm = verification_key_manager.clone(); // TODO: this is silly
    let get_root_key = Box::new(move |kid| {
        vkm.get_root_key(&kid)
            .map(|rk| Box::new(rk) as Box<dyn PublicKey>)
    }) as GetKeyFn;
    let (_, claims) = jwts.into_iter().fold(
        Ok((get_root_key, default_claims)),
        |accumulated, jwt| -> Result<(_, VKM::Claims)> {
            let (get_key, acc) = accumulated?;
            let full_claims: FullClaims<VKM::JWK, VKM::Claims> =
                decode_inner_jwt(jwt_decoder, &jwt, get_key)?;
            let next_pub_key =
                verification_key_manager.jwk_to_public_attenuation_key(&full_claims.aky);
            let get_key = Box::new(move |kid: Option<String>| {
                next_pub_key.and_then(|p| {
                    let kids_match = kid.as_ref().map(|kid| kid == p.key_id()).unwrap_or(true);
                    if kids_match {
                        Some(Box::new(p) as Box<dyn PublicKey>)
                    } else {
                        None
                    }
                })
            }) as GetKeyFn;
            let accumulated = resolve_claims(acc, full_claims.user_provided_claims);
            Ok((get_key, accumulated))
        },
    )?;
    Ok(claims)
}

fn final_attenuation_key<VKM: VerificationKeyManager, JWTD: JWTDecoder>(
    verification_key_manager: &VKM,
    jwt_decoder: &JWTD,
    jwt: &SignedJWT,
) -> Result<VKM::PublicAttenuationKey> {
    let claims: SealedClaims = jwt_decoder.insecurely_decode_jwt(jwt)?;

    claims
        .jwts
        .last()
        .ok_or(Error::MissingFinalAttenuationKey)
        .and_then(|jwt| extract_aky(verification_key_manager, jwt_decoder, jwt))
}

fn extract_aky<VKM: VerificationKeyManager, JWTD: JWTDecoder>(
    verification_key_manager: &VKM,
    jwt_decoder: &JWTD,
    jwt: &SignedJWT,
) -> Result<VKM::PublicAttenuationKey> {
    let claims: FullClaims<VKM::JWK, HashMap<String, String>> =
        jwt_decoder.insecurely_decode_jwt(jwt)?;
    verification_key_manager
        .jwk_to_public_attenuation_key(&claims.aky)
        .ok_or(Error::MalformedAttenuationKeyJWK)
}

fn decode_inner_jwt<JWTD: JWTDecoder, Claims: DeserializeOwned>(
    jwt_decoder: &JWTD,
    jwt: &SignedJWT,
    get_key: GetKeyFn,
) -> Result<Claims> {
    let header = jwt_decoder.decode_jwt_header(jwt)?;
    let kid = header.key_id.clone();
    let public_key = get_key(kid).ok_or_else(|| Error::MissingKey(header.key_id.clone()))?;
    jwt_decoder.decode_jwt(
        jwt,
        public_key.as_ref(),
        &VerificationRequirements::VerifySignatureOnly {
            acceptable_algorithms: vec![public_key.algorithm().to_owned()],
        },
    )
}

#[cfg(test)]
mod test {
    use crate::{
        ed25519,
        protocol::{
            AttenuationKeyGenerator, FullClaims, Issuer, JWTDecoder, JWTHeader, PrivateKey,
            PublicKey, SealedClaims, SecondsSinceEpoch, SignedJWT, SigningKeyManager,
            VerificationKeyManager, VerificationRequirements,
        },
        sign::Error as SignError,
        verify::Error,
    };
    use jsonwebtoken::{decode, decode_header, Algorithm, DecodingKey, EncodingKey, Validation};
    use mockall::mock;
    use serde::{de::DeserializeOwned, Serialize};
    use std::{
        collections::HashMap,
        str::FromStr,
        time::{SystemTime, UNIX_EPOCH},
    };

    use super::verify;

    const EXPECTED_ISSUER: &str = "my-issuer";

    mock! {
        KeyManager {}

        impl VerificationKeyManager for KeyManager {
            type PublicRootKey = ed25519::Ed25519PublicKey;

            type PublicAttenuationKey = ed25519::Ed25519PublicKey;

            type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;

            type Claims = std::collections::HashMap<String, String>;

            type JWK = ed25519::JWK;

            fn get_root_key(&self, key_id: &Option<String>) -> Option<<MockKeyManager as VerificationKeyManager>::PublicRootKey>;
            fn get_envelope_verification_requirements(&self) -> VerificationRequirements;
            fn default_claims(&self) -> <MockKeyManager as VerificationKeyManager>::Claims;
            fn jwk_to_public_attenuation_key(&self, jwk: &<MockKeyManager as VerificationKeyManager>::JWK) -> Option<<MockKeyManager as VerificationKeyManager>::PublicAttenuationKey>;
        }

        impl Clone for KeyManager {
            fn clone(&self) -> Self;
        }
    }

    struct VerifyJWTDecoder;

    impl JWTDecoder for VerifyJWTDecoder {
        fn decode_jwt<Claims: DeserializeOwned, PubKey: PublicKey + ?Sized>(
            &self,
            jwt: &SignedJWT,
            verification_key: &PubKey,
            verification_reqs: &VerificationRequirements,
        ) -> crate::verify::Result<Claims> {
            let mut json: Vec<u8> = Default::default();
            erased_serde::serialize(
                verification_key,
                &mut serde_json::Serializer::new(&mut json),
            )
            .map_err(|_| crate::verify::Error::InvalidKey)?;
            let jwk: ed25519::JWK =
                serde_json::from_slice(&json).map_err(|_| crate::verify::Error::InvalidKey)?;
            let x = base64::decode_config(&jwk.x, base64::URL_SAFE_NO_PAD)
                .map_err(|_| Error::MalformedAttenuationKeyJWK)?;
            let decoding_key = DecodingKey::from_ed_der(&x);
            Ok(decode(
                jwt.as_ref(),
                &decoding_key,
                &validation_config(verification_reqs)?,
            )
            .map_err(|err| crate::verify::Error::JWTError(Some(Box::new(err))))?
            .claims)
        }

        fn insecurely_decode_jwt<Claims: DeserializeOwned>(
            &self,
            jwt: &SignedJWT,
        ) -> crate::verify::Result<Claims> {
            let no_validation = {
                let mut v = Validation::default();
                v.required_spec_claims.clear();
                v.insecure_disable_signature_validation();
                v
            };
            Ok(decode(
                jwt.as_ref(),
                &DecodingKey::from_secret("fake".as_ref()),
                &no_validation,
            )
            .map_err(|err| crate::verify::Error::JWTError(Some(Box::new(err))))?
            .claims)
        }

        fn decode_jwt_header(&self, jwt: &SignedJWT) -> crate::verify::Result<JWTHeader> {
            let header = decode_header(jwt.as_ref())
                .map_err(|err| crate::verify::Error::JWTError(Some(Box::new(err))))?;
            Ok(JWTHeader {
                key_id: header.kid,
                algorithm: format!("{:?}", header.alg),
            })
        }
    }

    fn to_encoding_key<PrivKey: PrivateKey>(k: &PrivKey) -> Result<EncodingKey> {
        let mut json: Vec<u8> = Default::default();
        erased_serde::serialize(k, &mut serde_json::Serializer::new(&mut json))
            .map_err(|_| crate::verify::Error::InvalidKey)?;
        let jwk: ed25519::JWK =
            serde_json::from_slice(&json).map_err(|_| crate::verify::Error::InvalidKey)?;
        if let Some(d) = &jwk.d {
            let x = base64::decode_config(&jwk.x, base64::URL_SAFE_NO_PAD)?;
            let d = base64::decode_config(&d, base64::URL_SAFE_NO_PAD)?;
            let der: Vec<_> = x.into_iter().chain(d.into_iter()).collect();
            let encoding_key = EncodingKey::from_ed_der(&der);
            Ok(encoding_key)
        } else {
            Err(Error::InvalidKey)?
        }
    }

    type Result<R> = std::result::Result<R, Box<dyn std::error::Error>>;

    fn make_inner_jwt<SignWith: PrivateKey, NextKeyJWK: Serialize>(
        sign_with: SignWith,
        next_key_jwk: NextKeyJWK,
    ) -> Result<SignedJWT> {
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &sign_with.algorithm(),
            )?);
            header.kid = Some(sign_with.key_id().to_owned());
            header
        };
        let claims: FullClaims<NextKeyJWK, HashMap<String, String>> =
            FullClaims::new(Default::default(), next_key_jwk);
        let inner_jwt = jsonwebtoken::encode(&header, &claims, &to_encoding_key(&sign_with)?)?;
        Ok(SignedJWT(inner_jwt))
    }

    fn make_envelope_jwt<SignWith: PrivateKey>(
        sign_with: SignWith,
        inner_jwts: Vec<SignedJWT>,
    ) -> Result<SignedJWT> {
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &sign_with.algorithm(),
            )?);
            header.kid = Some(sign_with.key_id().to_owned());
            header
        };
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let full_claims = SealedClaims {
            exp: Some(SecondsSinceEpoch(current_time + 60)),
            nbf: Some(SecondsSinceEpoch(current_time)),
            iss: Some(Issuer(EXPECTED_ISSUER.to_owned())),
            aud: None,
            jwts: inner_jwts,
        };
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&sign_with)?)?;
        Ok(SignedJWT(token))
    }

    #[test]
    fn test_wrong_aky_chain() -> Result<()> {
        let (envelope_pub_key, envelope_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let (correct_inner2_pub_key, _) = SignKeyManager.generate_attenuation_key()?;
        let (_, wrong_inner2_priv_key) = SignKeyManager.generate_attenuation_key()?;

        let (_, inner1_priv_key) = SignKeyManager.generate_attenuation_key()?;

        let inner1 = make_inner_jwt(inner1_priv_key, ed25519::JWK::from(&correct_inner2_pub_key))?;
        let inner2 = make_inner_jwt(wrong_inner2_priv_key, ed25519::JWK::from(&envelope_pub_key))?;

        let token = make_envelope_jwt(envelope_priv_key, vec![inner1, inner2])?;

        fn make_key_manager(root_key: ed25519::Ed25519PublicKey) -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
                .expect_default_claims()
                .returning(|| Default::default());
            let cloned_root_key = root_key.clone();
            key_manager
                .expect_clone()
                .returning(move || make_key_manager(cloned_root_key.clone()));
            key_manager
                .expect_get_root_key()
                .returning(move |_| Some(root_key.clone()));
            key_manager
        }

        let key_manager = make_key_manager(envelope_pub_key);
        let err = verify(key_manager, &VerifyJWTDecoder, token, |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::JWTError(_),
        ));

        Ok(())
    }

    #[test]
    fn test_wrong_envelope_key() -> Result<()> {
        let (correct_envelope_pub_key, _) = SignKeyManager.generate_attenuation_key()?;
        let (_, incorrect_envelope_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let (_, inner_priv_key) = SignKeyManager.generate_attenuation_key()?;

        let inner_jwt = make_inner_jwt(
            inner_priv_key,
            ed25519::JWK::from(&correct_envelope_pub_key),
        )?;

        let token = make_envelope_jwt(incorrect_envelope_priv_key, vec![inner_jwt])?;

        fn make_key_manager() -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
        }

        let key_manager = make_key_manager();
        let err = verify(key_manager, &VerifyJWTDecoder, token, |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::JWTError(_),
        ));

        Ok(())
    }

    #[test]
    fn test_bad_envelope_kid() -> Result<()> {
        let (_, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &root_priv_key.algorithm(),
            )?);
            header.kid = Some("wrong".to_owned());
            header
        };
        let full_claims = SealedClaims {
            exp: None,
            nbf: None,
            iss: None,
            aud: None,
            jwts: Default::default(),
        };
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&root_priv_key)?)?;

        let key_manager = MockKeyManager::new();
        let err = verify(
            key_manager,
            &VerifyJWTDecoder,
            SignedJWT(token),
            |mut c1, c2| {
                c1.extend(c2);
                c1
            },
        );

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::MissingFinalAttenuationKey
        ));

        Ok(())
    }

    #[test]
    fn test_missing_jwts_claim() -> Result<()> {
        let (_, root_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let header = {
            let mut header = jsonwebtoken::Header::new(jsonwebtoken::Algorithm::from_str(
                &root_priv_key.algorithm(),
            )?);
            header.kid = Some(root_priv_key.key_id().to_owned());
            header
        };
        // no jwts claim
        let full_claims: HashMap<String, String> = Default::default();
        let token = jsonwebtoken::encode(&header, &full_claims, &to_encoding_key(&root_priv_key)?)?;

        let key_manager = MockKeyManager::new();
        let err = verify(
            key_manager,
            &VerifyJWTDecoder,
            SignedJWT(token),
            |mut c1, c2| {
                c1.extend(c2);
                c1
            },
        );

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::JWTError(_)
        ));

        Ok(())
    }

    #[test]
    fn test_bad_encoding() {
        let key_manager = MockKeyManager::new();
        let err = verify(
            key_manager,
            &VerifyJWTDecoder,
            SignedJWT("*&".to_owned()),
            |mut c1, c2| {
                c1.extend(c2);
                c1
            },
        );

        assert!(matches!(
            err.expect_err("should have failed"),
            Error::JWTError(_)
        ));
    }

    #[test]
    fn test_missing_root_key() -> Result<()> {
        fn make_key_manager() -> MockKeyManager {
            let mut key_manager = MockKeyManager::new();
            key_manager
                .expect_jwk_to_public_attenuation_key()
                .returning(|jwk| jwk.try_into().ok());
            key_manager
                .expect_get_envelope_verification_requirements()
                .returning(|| VerificationRequirements::VerifyClaims {
                    acceptable_algorithms: vec![ed25519::EDDSA_ALGORITHM.to_owned()],
                    acceptable_issuers: Some(vec![Issuer(EXPECTED_ISSUER.to_owned())]),
                    acceptable_audiences: None,
                    acceptable_subject: None,
                });
            key_manager
                .expect_default_claims()
                .returning(|| Default::default());
            key_manager.expect_clone().returning(|| make_key_manager());
            key_manager.expect_get_root_key().returning(|_| None);
            key_manager
        }

        let (envelope_pub_key, envelope_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let (_, inner_priv_key) = SignKeyManager.generate_attenuation_key()?;
        let inner = make_inner_jwt(inner_priv_key, ed25519::JWK::from(&envelope_pub_key))?;
        let jwt = make_envelope_jwt(envelope_priv_key, vec![inner])?;

        let key_manager = make_key_manager();
        let err = verify(key_manager, &VerifyJWTDecoder, jwt, |mut c1, c2| {
            c1.extend(c2);
            c1
        });

        if let Error::MissingKey(Some(kid)) = err.expect_err("should have failed") {
            assert_eq!(kid, "aky");
        } else {
            assert!(false, "expected a MissingKey error");
        }

        Ok(())
    }

    #[derive(Clone)]
    struct SignKeyManager;

    impl AttenuationKeyGenerator<ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey>
        for SignKeyManager
    {
        fn generate_attenuation_key(
            &self,
        ) -> std::result::Result<(ed25519::Ed25519PublicKey, ed25519::Ed25519PrivateKey), SignError>
        {
            ed25519::EddsaKeyGen.generate_attenuation_key()
        }
    }

    impl SigningKeyManager for SignKeyManager {
        type JWK = ed25519::JWK;

        type PublicAttenuationKey = ed25519::Ed25519PublicKey;

        type PrivateAttenuationKey = ed25519::Ed25519PrivateKey;

        type PrivateRootKey = ed25519::Ed25519PrivateKey;

        type Claims = HashMap<String, String>;

        fn jwk_for_public_attenuation_key(
            public_attenuation_key: &Self::PublicAttenuationKey,
        ) -> Self::JWK {
            public_attenuation_key.into()
        }
    }

    fn validation_config(reqs: &VerificationRequirements) -> crate::verify::Result<Validation> {
        match reqs {
            VerificationRequirements::VerifyClaims {
                acceptable_algorithms,
                acceptable_audiences,
                acceptable_issuers,
                acceptable_subject,
            } => {
                let required_spec_claims = {
                    let mut required_spec_claims = vec!["exp".to_owned()];

                    if acceptable_audiences.is_some() {
                        required_spec_claims.push("aud".to_owned());
                    }

                    if acceptable_issuers.is_some() {
                        required_spec_claims.push("iss".to_owned());
                    }

                    if acceptable_subject.is_some() {
                        required_spec_claims.push("sub".to_owned());
                    }

                    required_spec_claims
                };

                let mut v = Validation::default();
                v.set_required_spec_claims(required_spec_claims.as_slice());
                v.validate_nbf = true;
                if let Some(issuers) = acceptable_issuers.as_ref() {
                    v.set_issuer(
                        issuers
                            .iter()
                            .map(|i| i.as_ref())
                            .collect::<Vec<_>>()
                            .as_slice(),
                    )
                }
                if let Some(audiences) = acceptable_audiences.as_ref() {
                    v.set_audience(
                        audiences
                            .iter()
                            .map(|a| a.as_ref())
                            .collect::<Vec<_>>()
                            .as_slice(),
                    )
                }
                v.sub = acceptable_subject.clone();
                v.algorithms = acceptable_algorithms
                    .iter()
                    .map(|alg| alg.to_string().parse())
                    .collect::<std::result::Result<_, _>>()
                    .map_err(|err| crate::verify::Error::JWTError(Some(Box::new(err))))?;

                Ok(v)
            }
            VerificationRequirements::VerifySignatureOnly {
                acceptable_algorithms,
            } => {
                let mut v = Validation::default();
                v.set_required_spec_claims(&[] as &[&str]);
                v.algorithms = acceptable_algorithms
                    .iter()
                    .map(|alg| alg.parse())
                    .collect::<std::result::Result<Vec<Algorithm>, jsonwebtoken::errors::Error>>()
                    .map_err(|err| crate::verify::Error::JWTError(Some(Box::new(err))))?;
                Ok(v)
            }
        }
    }
}
